/*
This function blocks until the given amount of time has passed, while maintaining low level behaviors (tag tracking and altitude control).
@param inputSecondsToWait: The number of seconds to wait

@exceptions: This function can throw exceptions
*/
void ARDroneControllerNode::waitSeconds(double inputSecondsToWait)
{
//Get the start time
auto originalTime = std::chrono::high_resolution_clock::now();
//Lock mutex so data can be accessed
std::unique_lock<std::mutex> uniqueLock(navDataMutex, std::defer_lock);
SOM_TRY
uniqueLock.lock();
SOM_CATCH("Error locking navdata mutex\n")

while(true)
{
auto currentTime = std::chrono::high_resolution_clock::now();
auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(currentTime - originalTime);

if(elapsedTime.count() >= inputSecondsToWait*1000.0)
{
break; //Timer finished
}

//Handle low level behaviors
SOM_TRY
handleLowLevelBehavior(uniqueLock);
SOM_CATCH("Error handling low level behavior\n")

SOM_TRY
waitUntilNextNavDataUpdate(uniqueLock); //Wait until next update
SOM_CATCH("Error waiting for next nav update\n")
}

} 
